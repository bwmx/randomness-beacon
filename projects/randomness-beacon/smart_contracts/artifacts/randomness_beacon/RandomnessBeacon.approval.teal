#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 5 8
    bytecblock "totalPendingRequests" "manager" "pauser" "paused" 0x151f7c75 "requests" "currentRequestId" "publicKey" "box mbr refund" 0x068101
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:15
    // key: 'manager',
    bytec_1 // "manager"
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:16
    // initialValue: new arc4.Address(Global.creatorAddress),
    global CreatorAddress
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:14-17
    // private _manager = GlobalState<arc4.Address>({
    //   key: 'manager',
    //   initialValue: new arc4.Address(Global.creatorAddress),
    // })
    app_global_put
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:8
    // key: 'pauser',
    bytec_2 // "pauser"
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:9
    // initialValue: new arc4.Address(Global.creatorAddress),
    global CreatorAddress
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:7-10
    // private _pauser = GlobalState<arc4.Address>({
    //   key: 'pauser',
    //   initialValue: new arc4.Address(Global.creatorAddress),
    // })
    app_global_put
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:13
    // paused = GlobalState<arc4.Bool>({ key: 'paused', initialValue: new arc4.Bool(false) })
    bytec_3 // "paused"
    pushbytes 0x00
    app_global_put
    // smart_contracts/randomness_beacon/contract.algo.ts:52
    // currentRequestId = GlobalState<arc4.UintN64>({ key: 'currentRequestId', initialValue: new arc4.UintN64(1) })
    bytec 6 // "currentRequestId"
    pushbytes 0x0000000000000001
    app_global_put
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    bytec_0 // "totalPendingRequests"
    pushbytes 0x0000000000000000
    app_global_put

main_after_if_else@2:
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txn NumAppArgs
    bz main_after_if_else@22
    pushbytess 0xefcbd3cb 0x46f76533 0x2487c32c 0xd898eeb7 0xf12c629e 0x21b69c59 0x6c19615a 0x8960168e 0xd48d426c 0x67434031 0x0178f94b 0x1b529de8 0x0cadd163 0xb0d953b3 // method "createApplication(byte[32])void", method "updateApplication()void", method "deleteApplication()void", method "createRequest(address,uint64,pay)uint64", method "cancelRequest(uint64)void", method "completeRequest(uint64,byte[80])void", method "getCosts()(uint64,uint64)", method "updateManager(address)void", method "deleteManager()void", method "manager()address", method "pause()void", method "unpause()void", method "updatePauser(address)void", method "pauser()address"
    txna ApplicationArgs 0
    match main_createApplication_route@5 main_updateApplication_route@6 main_deleteApplication_route@7 main_createRequest_route@8 main_cancelRequest_route@9 main_completeRequest_route@10 main_getCosts_route@11 main_updateManager_route@12 main_deleteManager_route@13 main_manager_route@14 main_pause_route@15 main_unpause_route@16 main_updatePauser_route@17 main_pauser_route@18

main_after_if_else@22:
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    intc_1 // 0
    return

main_pauser_route@18:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:50
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pauser
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_updatePauser_route@17:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:37
    // updatePauser(_newPauser: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:37
    // updatePauser(_newPauser: arc4.Address): void {
    callsub updatePauser
    intc_0 // 1
    return

main_unpause_route@16:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:31
    // unpause(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub unpause
    intc_0 // 1
    return

main_pause_route@15:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:23
    // pause(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub pause
    intc_0 // 1
    return

main_manager_route@14:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:55
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub manager
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_deleteManager_route@13:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:44
    // public deleteManager(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteManager
    intc_0 // 1
    return

main_updateManager_route@12:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:31
    // public updateManager(newManager: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:31
    // public updateManager(newManager: arc4.Address): void {
    callsub updateManager
    intc_0 // 1
    return

main_getCosts_route@11:
    // smart_contracts/randomness_beacon/contract.algo.ts:289
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCosts
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_completeRequest_route@10:
    // smart_contracts/randomness_beacon/contract.algo.ts:230
    // public completeRequest(requestId: arc4.UintN64, proof: arc4.StaticBytes<80>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/randomness_beacon/contract.algo.ts:230
    // public completeRequest(requestId: arc4.UintN64, proof: arc4.StaticBytes<80>): void {
    callsub completeRequest
    intc_0 // 1
    return

main_cancelRequest_route@9:
    // smart_contracts/randomness_beacon/contract.algo.ts:172
    // public cancelRequest(requestId: arc4.UintN64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/randomness_beacon/contract.algo.ts:172
    // public cancelRequest(requestId: arc4.UintN64): void {
    callsub cancelRequest
    intc_0 // 1
    return

main_createRequest_route@8:
    // smart_contracts/randomness_beacon/contract.algo.ts:107-111
    // public createRequest(
    //   requesterAddress: arc4.Address,
    //   round: arc4.UintN64,
    //   costsPayment: gtxn.PaymentTxn,
    // ): arc4.UintN64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/randomness_beacon/contract.algo.ts:107-111
    // public createRequest(
    //   requesterAddress: arc4.Address,
    //   round: arc4.UintN64,
    //   costsPayment: gtxn.PaymentTxn,
    // ): arc4.UintN64 {
    callsub createRequest
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_deleteApplication_route@7:
    // smart_contracts/randomness_beacon/contract.algo.ts:87
    // deleteApplication(): void {
    txn OnCompletion
    intc_2 // DeleteApplication
    ==
    assert // OnCompletion is not DeleteApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub deleteApplication
    intc_0 // 1
    return

main_updateApplication_route@6:
    // smart_contracts/randomness_beacon/contract.algo.ts:82
    // updateApplication(): void {
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    callsub updateApplication
    intc_0 // 1
    return

main_createApplication_route@5:
    // smart_contracts/randomness_beacon/contract.algo.ts:76
    // createApplication(publicKey: arc4.StaticBytes<32>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/randomness_beacon/contract.algo.ts:46-47
    // @contract({ name: 'RandomnessBeacon', avmVersion: 11 })
    // export class RandomnessBeacon extends classes(Managable, Pausable, Contract) implements arc4.ConventionalRouting {
    txna ApplicationArgs 1
    // smart_contracts/randomness_beacon/contract.algo.ts:76
    // createApplication(publicKey: arc4.StaticBytes<32>): void {
    callsub createApplication
    intc_0 // 1
    return


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.deleteRequest(requestId: bytes) -> void:
deleteRequest:
    // smart_contracts/randomness_beacon/contract.algo.ts:65
    // private deleteRequest(requestId: arc4.UintN64): void {
    proto 1 0
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    intc_1 // 0
    bytec_0 // "totalPendingRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:67
    // this.totalPendingRequests.value = new arc4.UintN64(this.totalPendingRequests.value.native - 1)
    btoi
    intc_0 // 1
    -
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    bytec_0 // "totalPendingRequests"
    // smart_contracts/randomness_beacon/contract.algo.ts:67
    // this.totalPendingRequests.value = new arc4.UintN64(this.totalPendingRequests.value.native - 1)
    swap
    app_global_put
    // smart_contracts/randomness_beacon/contract.algo.ts:55
    // requests = BoxMap<arc4.UintN64, RandomnessRequest>({ keyPrefix: 'requests' })
    bytec 5 // "requests"
    frame_dig -1
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:69
    // this.requests(requestId).delete()
    box_del
    pop
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.createApplication(publicKey: bytes) -> void:
createApplication:
    // smart_contracts/randomness_beacon/contract.algo.ts:76
    // createApplication(publicKey: arc4.StaticBytes<32>): void {
    proto 1 0
    // smart_contracts/randomness_beacon/contract.algo.ts:49
    // publicKey = GlobalState<arc4.StaticBytes<32>>({ key: 'publicKey' })
    bytec 7 // "publicKey"
    // smart_contracts/randomness_beacon/contract.algo.ts:78
    // this.publicKey.value = publicKey
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.updateApplication() -> void:
updateApplication:
    // smart_contracts/randomness_beacon/contract.algo.ts:83
    // this.onlyManager()
    callsub onlyManager
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.deleteApplication() -> void:
deleteApplication:
    // smart_contracts/randomness_beacon/contract.algo.ts:88
    // this.onlyManager()
    callsub onlyManager
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    intc_1 // 0
    bytec_0 // "totalPendingRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:90
    // assert(this.totalPendingRequests.value.native === 0, ERR_NO_PENDING_REQUESTS)
    btoi
    !
    assert // no pending requests
    // smart_contracts/randomness_beacon/contract.algo.ts:92-97
    // itxn
    //   .payment({
    //     closeRemainderTo: this.manager().native,
    //     note: NOTE_CLOSE_OUT_REMAINDER,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/randomness_beacon/contract.algo.ts:94
    // closeRemainderTo: this.manager().native,
    callsub manager
    // smart_contracts/randomness_beacon/types.algo.ts:17
    // export const NOTE_CLOSE_OUT_REMAINDER = 'close out remainder to manager'
    pushbytes "close out remainder to manager"
    itxn_field Note
    itxn_field CloseRemainderTo
    // smart_contracts/randomness_beacon/contract.algo.ts:92-96
    // itxn
    //   .payment({
    //     closeRemainderTo: this.manager().native,
    //     note: NOTE_CLOSE_OUT_REMAINDER,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:92-97
    // itxn
    //   .payment({
    //     closeRemainderTo: this.manager().native,
    //     note: NOTE_CLOSE_OUT_REMAINDER,
    //   })
    //   .submit()
    itxn_submit
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.createRequest(requesterAddress: bytes, round: bytes, costsPayment: uint64) -> bytes:
createRequest:
    // smart_contracts/randomness_beacon/contract.algo.ts:107-111
    // public createRequest(
    //   requesterAddress: arc4.Address,
    //   round: arc4.UintN64,
    //   costsPayment: gtxn.PaymentTxn,
    // ): arc4.UintN64 {
    proto 3 1
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:13
    // paused = GlobalState<arc4.Bool>({ key: 'paused', initialValue: new arc4.Bool(false) })
    intc_1 // 0
    bytec_3 // "paused"
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 0
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:16
    // assert(!this.paused.value.native)
    getbit
    !
    assert
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    intc_1 // 0
    bytec_0 // "totalPendingRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:115
    // assert(this.totalPendingRequests.value.native < MAX_PENDING_REQUESTS, ERR_MAX_PENDING_REQUESTS)
    btoi
    // smart_contracts/randomness_beacon/types.algo.ts:20
    // export const MAX_PENDING_REQUESTS: uint64 = 5
    intc_2 // 5
    // smart_contracts/randomness_beacon/contract.algo.ts:115
    // assert(this.totalPendingRequests.value.native < MAX_PENDING_REQUESTS, ERR_MAX_PENDING_REQUESTS)
    <
    assert // cannot exceed max pending requests
    // smart_contracts/randomness_beacon/contract.algo.ts:117
    // assert(round.native > Global.round, ERR_MUST_BE_FUTURE_ROUND)
    frame_dig -2
    btoi
    global Round
    >
    assert // must be a future round
    // smart_contracts/randomness_beacon/contract.algo.ts:119
    // const callerAppId = Global.callerApplicationId
    global CallerApplicationID
    dup
    // smart_contracts/randomness_beacon/contract.algo.ts:121
    // assert(callerAppId !== 0, ERR_MUST_BE_CALLED_FROM_APP)
    assert // must be called by an application
    // smart_contracts/randomness_beacon/contract.algo.ts:123
    // const [txnFees, boxCost] = this.getCosts().native
    callsub getCosts
    dup
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/randomness_beacon/contract.algo.ts:126-136
    // assertMatch(
    //   costsPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       // should cover the required fees + box storage cost (will be refunded)
    //       greaterThanEq: txnFees.native + boxCost.native,
    //     },
    //   },
    //   ERR_COSTS_PAYMENT_MUST_BE_VALID,
    // )
    frame_dig -1
    gtxns Receiver
    // smart_contracts/randomness_beacon/contract.algo.ts:129
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/randomness_beacon/contract.algo.ts:126-136
    // assertMatch(
    //   costsPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       // should cover the required fees + box storage cost (will be refunded)
    //       greaterThanEq: txnFees.native + boxCost.native,
    //     },
    //   },
    //   ERR_COSTS_PAYMENT_MUST_BE_VALID,
    // )
    ==
    bz createRequest_bool_false@3
    frame_dig -1
    gtxns Amount
    // smart_contracts/randomness_beacon/contract.algo.ts:132
    // greaterThanEq: txnFees.native + boxCost.native,
    frame_dig 1
    dup
    // smart_contracts/randomness_beacon/contract.algo.ts:123
    // const [txnFees, boxCost] = this.getCosts().native
    intc_1 // 0
    // smart_contracts/randomness_beacon/contract.algo.ts:132
    // greaterThanEq: txnFees.native + boxCost.native,
    extract_uint64
    swap
    // smart_contracts/randomness_beacon/contract.algo.ts:123
    // const [txnFees, boxCost] = this.getCosts().native
    intc_3 // 8
    // smart_contracts/randomness_beacon/contract.algo.ts:132
    // greaterThanEq: txnFees.native + boxCost.native,
    extract_uint64
    +
    // smart_contracts/randomness_beacon/contract.algo.ts:126-136
    // assertMatch(
    //   costsPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       // should cover the required fees + box storage cost (will be refunded)
    //       greaterThanEq: txnFees.native + boxCost.native,
    //     },
    //   },
    //   ERR_COSTS_PAYMENT_MUST_BE_VALID,
    // )
    >=
    bz createRequest_bool_false@3
    intc_0 // 1

createRequest_bool_merge@4:
    // smart_contracts/randomness_beacon/contract.algo.ts:126-136
    // assertMatch(
    //   costsPayment,
    //   {
    //     receiver: Global.currentApplicationAddress,
    //     amount: {
    //       // should cover the required fees + box storage cost (will be refunded)
    //       greaterThanEq: txnFees.native + boxCost.native,
    //     },
    //   },
    //   ERR_COSTS_PAYMENT_MUST_BE_VALID,
    // )
    assert // costs payment must be valid
    // smart_contracts/randomness_beacon/contract.algo.ts:139
    // const feesPaid: uint64 = costsPayment.amount - boxCost.native
    frame_dig -1
    gtxns Amount
    frame_dig 1
    // smart_contracts/randomness_beacon/contract.algo.ts:123
    // const [txnFees, boxCost] = this.getCosts().native
    intc_3 // 8
    // smart_contracts/randomness_beacon/contract.algo.ts:139
    // const feesPaid: uint64 = costsPayment.amount - boxCost.native
    extract_uint64
    -
    // smart_contracts/randomness_beacon/contract.algo.ts:142
    // createdAt: new arc4.UintN64(Global.round),
    global Round
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:143
    // requesterAppId: new arc4.UintN64(callerAppId),
    frame_dig 0
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:146
    // feePaid: new arc4.UintN64(feesPaid),
    uncover 2
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:141-148
    // const request = new RandomnessRequest({
    //   createdAt: new arc4.UintN64(Global.round),
    //   requesterAppId: new arc4.UintN64(callerAppId),
    //   requesterAddress: requesterAddress,
    //   round: round,
    //   feePaid: new arc4.UintN64(feesPaid),
    //   boxCost: boxCost,
    // })
    uncover 2
    dig 2
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    swap
    concat
    frame_dig 2
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:52
    // currentRequestId = GlobalState<arc4.UintN64>({ key: 'currentRequestId', initialValue: new arc4.UintN64(1) })
    intc_1 // 0
    bytec 6 // "currentRequestId"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:55
    // requests = BoxMap<arc4.UintN64, RandomnessRequest>({ keyPrefix: 'requests' })
    bytec 5 // "requests"
    dig 1
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:153
    // this.requests(requestId).value = request.copy()
    uncover 2
    box_put
    // smart_contracts/randomness_beacon/contract.algo.ts:155
    // this.currentRequestId.value = new arc4.UintN64(requestId.native + 1)
    dup
    btoi
    intc_0 // 1
    +
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:52
    // currentRequestId = GlobalState<arc4.UintN64>({ key: 'currentRequestId', initialValue: new arc4.UintN64(1) })
    bytec 6 // "currentRequestId"
    // smart_contracts/randomness_beacon/contract.algo.ts:155
    // this.currentRequestId.value = new arc4.UintN64(requestId.native + 1)
    swap
    app_global_put
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    intc_1 // 0
    bytec_0 // "totalPendingRequests"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:157
    // this.totalPendingRequests.value = new arc4.UintN64(this.totalPendingRequests.value.native + 1)
    btoi
    intc_0 // 1
    +
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:58
    // totalPendingRequests = GlobalState<arc4.UintN64>({ key: 'totalPendingRequests', initialValue: new arc4.UintN64(0) })
    bytec_0 // "totalPendingRequests"
    // smart_contracts/randomness_beacon/contract.algo.ts:157
    // this.totalPendingRequests.value = new arc4.UintN64(this.totalPendingRequests.value.native + 1)
    swap
    app_global_put
    // smart_contracts/randomness_beacon/contract.algo.ts:161-166
    // new RequestCreated({
    //   requestId: requestId,
    //   requesterAppId: new arc4.UintN64(callerAppId),
    //   requesterAddress: requesterAddress,
    //   round: round,
    // }),
    dup
    uncover 2
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:160-167
    // emit(
    //   new RequestCreated({
    //     requestId: requestId,
    //     requesterAppId: new arc4.UintN64(callerAppId),
    //     requesterAddress: requesterAddress,
    //     round: round,
    //   }),
    // )
    pushbytes 0xd06b56e6 // method "RequestCreated(uint64,uint64,address,uint64)"
    swap
    concat
    log
    // smart_contracts/randomness_beacon/contract.algo.ts:169
    // return requestId
    frame_bury 0
    retsub

createRequest_bool_false@3:
    intc_1 // 0
    b createRequest_bool_merge@4


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.cancelRequest(requestId: bytes) -> void:
cancelRequest:
    // smart_contracts/randomness_beacon/contract.algo.ts:172
    // public cancelRequest(requestId: arc4.UintN64): void {
    proto 1 0
    // smart_contracts/randomness_beacon/contract.algo.ts:55
    // requests = BoxMap<arc4.UintN64, RandomnessRequest>({ keyPrefix: 'requests' })
    bytec 5 // "requests"
    frame_dig -1
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:174
    // const request: RandomnessRequest = this.requests(requestId).value.copy()
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // smart_contracts/randomness_beacon/contract.algo.ts:176
    // assert(Global.round >= request.round.native + MAX_PENDING_TIME, 'must be after the max pending time')
    global Round
    dig 1
    pushint 48 // 48
    extract_uint64
    // smart_contracts/randomness_beacon/types.algo.ts:22
    // export const MAX_PENDING_TIME: uint64 = 100 // should be 1000
    pushint 100 // 100
    // smart_contracts/randomness_beacon/contract.algo.ts:176
    // assert(Global.round >= request.round.native + MAX_PENDING_TIME, 'must be after the max pending time')
    +
    >=
    assert // must be after the max pending time
    // smart_contracts/randomness_beacon/contract.algo.ts:178
    // let amountToRefund: uint64 = request.boxCost.native + request.feePaid.native
    dup
    pushint 64 // 64
    extract_uint64
    dig 1
    pushint 56 // 56
    extract_uint64
    +
    dup
    uncover 2
    // smart_contracts/randomness_beacon/contract.algo.ts:181
    // if (request.requesterAddress.native !== Txn.sender) {
    extract 16 32 // on error: Index access is out of bounds
    dup
    cover 2
    txn Sender
    !=
    bz cancelRequest_after_if_else@3
    // smart_contracts/randomness_beacon/contract.algo.ts:187
    // const cancellationFees: uint64 = Global.minTxnFee * 3
    global MinTxnFee
    pushint 3 // 3
    *
    // smart_contracts/randomness_beacon/contract.algo.ts:190
    // amountToRefund -= cancellationFees
    frame_dig 1
    dig 1
    -
    // smart_contracts/randomness_beacon/contract.algo.ts:193-200
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: cancellationFees,
    //     note: NOTE_CANCEL_PAYMENT,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/randomness_beacon/contract.algo.ts:195
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/randomness_beacon/types.algo.ts:16
    // export const NOTE_CANCEL_PAYMENT = 'cancellation fees for caller'
    pushbytes "cancellation fees for caller"
    itxn_field Note
    uncover 2
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/randomness_beacon/contract.algo.ts:193-199
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: cancellationFees,
    //     note: NOTE_CANCEL_PAYMENT,
    //     fee: 0,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/randomness_beacon/contract.algo.ts:198
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:193-200
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: cancellationFees,
    //     note: NOTE_CANCEL_PAYMENT,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    frame_bury 3

cancelRequest_after_if_else@3:
    frame_dig 3
    // smart_contracts/randomness_beacon/contract.algo.ts:204-211
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: amountToRefund,
    //     note: NOTE_BOX_MBR_REFUND, // TODO: make a new note that explains this better
    //     fee: 0, // force group to cover it
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/randomness_beacon/types.algo.ts:14
    // export const NOTE_BOX_MBR_REFUND = 'box mbr refund'
    bytec 8 // "box mbr refund"
    itxn_field Note
    itxn_field Amount
    frame_dig 2
    dup
    itxn_field Receiver
    // smart_contracts/randomness_beacon/contract.algo.ts:204-210
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: amountToRefund,
    //     note: NOTE_BOX_MBR_REFUND, // TODO: make a new note that explains this better
    //     fee: 0, // force group to cover it
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/randomness_beacon/contract.algo.ts:209
    // fee: 0, // force group to cover it
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:204-211
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: amountToRefund,
    //     note: NOTE_BOX_MBR_REFUND, // TODO: make a new note that explains this better
    //     fee: 0, // force group to cover it
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/randomness_beacon/contract.algo.ts:217
    // requesterAppId: request.requesterAppId,
    frame_dig 0
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/randomness_beacon/contract.algo.ts:215-219
    // new RequestCancelled({
    //   requestId: requestId,
    //   requesterAppId: request.requesterAppId,
    //   requesterAddress: request.requesterAddress,
    // }),
    frame_dig -1
    swap
    concat
    swap
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:214-220
    // emit(
    //   new RequestCancelled({
    //     requestId: requestId,
    //     requesterAppId: request.requesterAppId,
    //     requesterAddress: request.requesterAddress,
    //   }),
    // )
    pushbytes 0xc51cf67d // method "RequestCancelled(uint64,uint64,address)"
    swap
    concat
    log
    // smart_contracts/randomness_beacon/contract.algo.ts:222
    // this.deleteRequest(requestId)
    frame_dig -1
    callsub deleteRequest
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.completeRequest(requestId: bytes, proof: bytes) -> void:
completeRequest:
    // smart_contracts/randomness_beacon/contract.algo.ts:230
    // public completeRequest(requestId: arc4.UintN64, proof: arc4.StaticBytes<80>): void {
    proto 2 0
    // smart_contracts/randomness_beacon/contract.algo.ts:232
    // this.onlyManager()
    callsub onlyManager
    // smart_contracts/randomness_beacon/contract.algo.ts:55
    // requests = BoxMap<arc4.UintN64, RandomnessRequest>({ keyPrefix: 'requests' })
    bytec 5 // "requests"
    frame_dig -2
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:234
    // const request: RandomnessRequest = this.requests(requestId).value.copy()
    box_get
    swap
    dup
    uncover 2
    assert // Box must have value
    // smart_contracts/randomness_beacon/contract.algo.ts:236
    // const blockSeed = op.Block.blkSeed(request.round.native)
    pushint 48 // 48
    extract_uint64
    block BlkSeed

completeRequest_while_top@5:
    pushint 5710 // 5710
    global OpcodeBudget
    >
    bz completeRequest_after_while@10
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    intc_2 // DeleteApplication
    itxn_field OnCompletion
    bytec 9 // 0x068101
    itxn_field ApprovalProgram
    bytec 9 // 0x068101
    itxn_field ClearStateProgram
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    b completeRequest_while_top@5

completeRequest_after_while@10:
    // smart_contracts/randomness_beacon/contract.algo.ts:49
    // publicKey = GlobalState<arc4.StaticBytes<32>>({ key: 'publicKey' })
    intc_1 // 0
    bytec 7 // "publicKey"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contract.algo.ts:240
    // const [output, verified] = op.vrfVerify(VrfVerify.VrfAlgorand, blockSeed, proof.bytes, this.publicKey.value.bytes)
    frame_dig 1
    frame_dig -1
    uncover 2
    vrf_verify VrfAlgorand
    // smart_contracts/randomness_beacon/contract.algo.ts:242
    // assert(verified, ERR_PROOF_MUST_BE_VALID)
    assert // proof must be valid
    // smart_contracts/randomness_beacon/contract.algo.ts:245-249
    // const r = arc4.abiCall(RandomnessBeaconCallerStub.prototype.fulfillRandomness, {
    //   appId: request.requesterAppId.native,
    //   args: [requestId, request.requesterAddress, new arc4.StaticBytes<64>(output)],
    //   fee: 0,
    // })
    itxn_begin
    // smart_contracts/randomness_beacon/contract.algo.ts:246
    // appId: request.requesterAppId.native,
    frame_dig 0
    dup
    extract 8 8 // on error: Index access is out of bounds
    dig 1
    intc_3 // 8
    extract_uint64
    // smart_contracts/randomness_beacon/contract.algo.ts:247
    // args: [requestId, request.requesterAddress, new arc4.StaticBytes<64>(output)],
    dig 2
    extract 16 32 // on error: Index access is out of bounds
    dig 4
    len
    pushint 64 // 64
    ==
    assert // invalid size
    // smart_contracts/randomness_beacon/contract.algo.ts:245-249
    // const r = arc4.abiCall(RandomnessBeaconCallerStub.prototype.fulfillRandomness, {
    //   appId: request.requesterAppId.native,
    //   args: [requestId, request.requesterAddress, new arc4.StaticBytes<64>(output)],
    //   fee: 0,
    // })
    pushbytes 0x42cbfe4c // method "fulfillRandomness(uint64,address,byte[64])void"
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    // smart_contracts/randomness_beacon/contract.algo.ts:248
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:245-249
    // const r = arc4.abiCall(RandomnessBeaconCallerStub.prototype.fulfillRandomness, {
    //   appId: request.requesterAppId.native,
    //   args: [requestId, request.requesterAddress, new arc4.StaticBytes<64>(output)],
    //   fee: 0,
    // })
    itxn_submit
    // smart_contracts/randomness_beacon/contract.algo.ts:252-259
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: request.feePaid.native,
    //     note: NOTE_FEES_PAYMENT,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/randomness_beacon/contract.algo.ts:254
    // receiver: Txn.sender,
    txn Sender
    // smart_contracts/randomness_beacon/contract.algo.ts:255
    // amount: request.feePaid.native,
    dig 3
    pushint 56 // 56
    extract_uint64
    // smart_contracts/randomness_beacon/types.algo.ts:15
    // export const NOTE_FEES_PAYMENT = 'fees payment for caller'
    pushbytes "fees payment for caller"
    itxn_field Note
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/randomness_beacon/contract.algo.ts:252-258
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: request.feePaid.native,
    //     note: NOTE_FEES_PAYMENT,
    //     fee: 0,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/randomness_beacon/contract.algo.ts:257
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:252-259
    // itxn
    //   .payment({
    //     receiver: Txn.sender,
    //     amount: request.feePaid.native,
    //     note: NOTE_FEES_PAYMENT,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/randomness_beacon/contract.algo.ts:262-269
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: request.boxCost.native,
    //     note: NOTE_BOX_MBR_REFUND,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/randomness_beacon/contract.algo.ts:265
    // amount: request.boxCost.native,
    uncover 2
    pushint 64 // 64
    extract_uint64
    // smart_contracts/randomness_beacon/types.algo.ts:14
    // export const NOTE_BOX_MBR_REFUND = 'box mbr refund'
    bytec 8 // "box mbr refund"
    itxn_field Note
    itxn_field Amount
    dup
    itxn_field Receiver
    // smart_contracts/randomness_beacon/contract.algo.ts:262-268
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: request.boxCost.native,
    //     note: NOTE_BOX_MBR_REFUND,
    //     fee: 0,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    // smart_contracts/randomness_beacon/contract.algo.ts:267
    // fee: 0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/randomness_beacon/contract.algo.ts:262-269
    // itxn
    //   .payment({
    //     receiver: request.requesterAddress.native,
    //     amount: request.boxCost.native,
    //     note: NOTE_BOX_MBR_REFUND,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/randomness_beacon/contract.algo.ts:273-277
    // new RequestFulfilled({
    //   requestId: requestId,
    //   requesterAppId: request.requesterAppId,
    //   requesterAddress: request.requesterAddress,
    // }),
    frame_dig -2
    uncover 2
    concat
    swap
    concat
    // smart_contracts/randomness_beacon/contract.algo.ts:272-278
    // emit(
    //   new RequestFulfilled({
    //     requestId: requestId,
    //     requesterAppId: request.requesterAppId,
    //     requesterAddress: request.requesterAddress,
    //   }),
    // )
    pushbytes 0x6ccc1cbe // method "RequestFulfilled(uint64,uint64,address)"
    swap
    concat
    log
    // smart_contracts/randomness_beacon/contract.algo.ts:281
    // this.deleteRequest(requestId)
    frame_dig -2
    callsub deleteRequest
    retsub


// smart_contracts/randomness_beacon/contract.algo.ts::RandomnessBeacon.getCosts() -> bytes:
getCosts:
    // smart_contracts/randomness_beacon/contract.algo.ts:299
    // const txnFees: uint64 = Global.minTxnFee * numRequiredTxns
    global MinTxnFee
    // smart_contracts/randomness_beacon/contract.algo.ts:297
    // const numRequiredTxns: uint64 = 8 + 2 + 1 + 1
    pushint 12 // 12
    // smart_contracts/randomness_beacon/contract.algo.ts:299
    // const txnFees: uint64 = Global.minTxnFee * numRequiredTxns
    *
    // smart_contracts/randomness_beacon/contract.algo.ts:316
    // return new arc4.Tuple(new arc4.UintN64(txnFees), new arc4.UintN64(boxCost))
    itob
    // smart_contracts/randomness_beacon/contract.algo.ts:314
    // const boxCost: uint64 = BOX_CREATE_COST + BOX_BYTE_COST * (keySize + boxSize)
    pushint 37700 // 37700
    // smart_contracts/randomness_beacon/contract.algo.ts:316
    // return new arc4.Tuple(new arc4.UintN64(txnFees), new arc4.UintN64(boxCost))
    itob
    concat
    retsub


// smart_contracts/randomness_beacon/contracts/managable.algo.ts::Managable.onlyManager() -> void:
onlyManager:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:15
    // key: 'manager',
    intc_1 // 0
    bytec_1 // "manager"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:24
    // assert(this._manager.value.native === Txn.sender, ERR_ONLY_MANAGER)
    txn Sender
    ==
    assert // only manager can perform this action
    retsub


// smart_contracts/randomness_beacon/contracts/managable.algo.ts::Managable.updateManager(newManager: bytes) -> void:
updateManager:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:31
    // public updateManager(newManager: arc4.Address): void {
    proto 1 0
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:33
    // this.onlyManager()
    callsub onlyManager
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:35
    // assert(newManager.native !== Global.zeroAddress, ERR_ZERO_ADDRESS)
    frame_dig -1
    global ZeroAddress
    !=
    assert // manager cannot be zero address
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:15
    // key: 'manager',
    bytec_1 // "manager"
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:37
    // this._manager.value = newManager
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contracts/managable.algo.ts::Managable.deleteManager() -> void:
deleteManager:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:46
    // this.onlyManager()
    callsub onlyManager
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:15
    // key: 'manager',
    bytec_1 // "manager"
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:48
    // this._manager.value = new arc4.Address(Global.zeroAddress)
    global ZeroAddress
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contracts/managable.algo.ts::Managable.manager() -> bytes:
manager:
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:15
    // key: 'manager',
    intc_1 // 0
    bytec_1 // "manager"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contracts/managable.algo.ts:57
    // return this._manager.value
    retsub


// smart_contracts/randomness_beacon/contracts/pausable.algo.ts::Pausable.onlyPauser() -> void:
onlyPauser:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:8
    // key: 'pauser',
    intc_1 // 0
    bytec_2 // "pauser"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:20
    // assert(this._pauser.value.native === Txn.sender, ERR_ONLY_PAUSER)
    txn Sender
    ==
    assert // only pauser can call this method
    retsub


// smart_contracts/randomness_beacon/contracts/pausable.algo.ts::Pausable.pause() -> void:
pause:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:24
    // this.onlyPauser()
    callsub onlyPauser
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:13
    // paused = GlobalState<arc4.Bool>({ key: 'paused', initialValue: new arc4.Bool(false) })
    bytec_3 // "paused"
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:26
    // this.paused.value = new arc4.Bool(true)
    pushbytes 0x80
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contracts/pausable.algo.ts::Pausable.unpause() -> void:
unpause:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:32
    // this.onlyPauser()
    callsub onlyPauser
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:13
    // paused = GlobalState<arc4.Bool>({ key: 'paused', initialValue: new arc4.Bool(false) })
    bytec_3 // "paused"
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:34
    // this.paused.value = new arc4.Bool(false)
    pushbytes 0x00
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contracts/pausable.algo.ts::Pausable.updatePauser(_newPauser: bytes) -> void:
updatePauser:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:37
    // updatePauser(_newPauser: arc4.Address): void {
    proto 1 0
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:38
    // this.onlyPauser()
    callsub onlyPauser
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:40
    // assert(_newPauser.native !== Global.zeroAddress, ERR_ZERO_ADDRESS)
    frame_dig -1
    global ZeroAddress
    !=
    assert // pauser cannot be zero address
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:8
    // key: 'pauser',
    bytec_2 // "pauser"
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:41
    // this._pauser.value = _newPauser
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/randomness_beacon/contracts/pausable.algo.ts::Pausable.pauser() -> bytes:
pauser:
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:8
    // key: 'pauser',
    intc_1 // 0
    bytec_2 // "pauser"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/randomness_beacon/contracts/pausable.algo.ts:52
    // return this._pauser.value
    retsub
